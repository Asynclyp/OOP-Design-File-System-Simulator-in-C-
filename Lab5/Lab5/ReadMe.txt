Kai Ang, Kevin Oloomi, Spark Li ReadMe.txt

Group Work Distribution:
    Kai: Primarily implemented the studios and lab and debugged to meet UnitTest requirements.
    Kevin: Primarily established the interface for early studios and debugged beyond the UnitTest requirements.
    Spark: Primarily reviewed the code for errors and conducted additional testing.

Test Cases:
1. The first test case that was ran was simply using the touch command to create a series of files. More specifically, these files were Kevin.img, Kai.txt, Spark.txt, imagefile.img, and textfile.txt. The output of all of these touch commands was successful as expected.
2. The second test case was used to test the touch command, however file extensions were incorrect such as ".tx" , ",txt" , ".im" and so forth. the command prompt returned "encountered an error" which signifies that these files could not be created and appended. Again this worked as expected.
3. The third test case was used to determine the functionality of the touch command without anything written after it. Again this returned "encountered an error" and funcitoned as expected.
4. The fourth test case was used to determine the functionality if an incorrect command name was written. This returned to the command prompt "command not found" and worked as expected since the command was not in the code.
5. The fifth test case was used to determine the functionality of the ls command. The files that were used in the initial test case were parsed into the system and the ls command was utilized. This displayed the files properly in the two columns and worked as expected.
6. The sixth test case was used to determine the functionality of the ls -m command. The files that were used in the initial test case were again used and the ls -m command was ran. This again functioned as expected listing all the files and simultaneously displaying some of the metadata information of each file.
7. The seventh test case was used to determine if ls-m (with no spaces) would function as a command. Since this is not the mannerism that it is implemented in the lab, this form did not execute and thus worked as expected.
8. The eighth test case was used to determine if the remove comand would work properly with a file in the system. Upon utilizing the remove command and then passing through ls, it was clear the file was removed and thus the program worked as expected.
9. The ninth test case was to determine how remove would function if an incorrect file name, or no file name at all was provided. In both of these cases, the command prompt returned encountered an error, indicating that the file could not be removed, and thus the program functioned as expected.
10. The tenth test case was to determine the process for utilizing the touch command along with password protection. a file was created utilizing the touch command and the -p extension. This properly created a file with the name and utilized a password (prompt was given to the user) in order to finish its creation. Further implementation of the password will be tested with subsequent commands.
11. The eleventh test case was to test the cat command. the first implementation of this test which was tested was without the -a marker. a file was created and the cat command added content to the text file (same was tested for an image file) after every enter (to form a new line) the data was saved and nothing occured. The user first typed in :wq and then displayed the file in which all the content was saved. The user then utilized the cat command once more adding text to the file, however this time :q was utilized and nothing was appended or saved to the file. This worked as expected.
12. The twelfth test case was to determine the functionality of the cat command along with the -a. A text file was created and text was apended to it utilizing the :wq ending. The cat command was then called on the same text file utilizing the -a ending and the information was added onto the file as expected.
13. The thirteenth test case was used to determine if the -a cat append feature could be used on an image file (in which it should not be used given the specification of prior studios). After following the same proceedure as test 12, it was determined that an error was produced indicating that the image could not be appended in this manner. Thus the program worked as expected.
14. The fourteenth test case was used to determine the functionality of the cat command on a file that was password protected. The user is able to type in the content that they want in the same fashion as the above test cases for cat described. however after the user finishes and types in :wq (to actually change the file), the command prompts the user to input the password. If the incorrect password is ran, then there is an error in which the command prompt states "an error has been encountered" otherwise, if the password is correct, the file is correctly concatinated or edited.
15. The fifteenth test case tested the formatted display command. For both text and image files, the display command was able to properly display the formatted information (array location of X's in .img and amount of white space for .txt) properly. Thus the command worked as functioned.
16. The sixteenth test case tested the unformatted display command. For both the text and image file the unformatted version of the display command properly printed the contents of the file to the command prompt without any formatting. The command worked as planned.
17. The seventeenth test case was utilized to test the copy command. Much the same as the example provided in the lab, a file was created and content was added to the file. The copy command was then called and the contents of the file were copied to that of another. The other file then had extrenuous information written to it and the display command was used to verify that both files are different. This worked as intented.
18. The eighteenth test case determined the functionality of a copy command with a password protected file. The file was able to be copied just the same as above, however in this situation the copied file maintained the same password as the original file, thus if any changes or displays were to be made of the copied file, the password is necessary. As a result of this it was determined that the command worked as expected.
19. The ninteenth test case determined the functionality of the rename command with a regular file, in which the file and its contents were copied to another file of a new name and the prior original file was deleted, thus renaming the file. This worked as expected.
20. The twentieth test case determined the functionality of the rename command with a password protected file in which the file and its contents along with the passowrd were copied to the new file. This again worked as expected.
21. The twentyfirst test case tested the creation and listing of files with multiple words names. Three files are created properly. The ls commands list every file with 0 size at the end as expected.
22. The twenty second test case used the previously created files with multiple names to test the functionality of copy command. One copy of each of the previously created files were made and listed properly with size of 0 as expected.
23. The twenty three test case used the previously created files with multiple names to test the functionality of cat and ds command. The three files were each wrote a string of different length. The ds command prints each file content as expected. Each file was properly listed with sizes that corresponds to the length of strings.
24. The twenty fourth test case used the previously created files with multiple names to test the functionality of rename. The names of all three files were changed and the listing function works properly as expected.
25. The twenty fifth test case used the previously created files with multiple names to test the functionality of remove. All three files were removed and the ls commnand gave no file as expected.
26. The last test case determined the functionality of the new MacroCommand that was added. In this situation, our implimentation included the Touch + cat command in which the user had to call qc followed by the file name and its extension. Just as the prior two independed commands worked, the macro command worked properly as well, functioning as expected.

Program Warnings:
 1. Throughout much of the program cpp files, it is clear that there are many initilizing conversions from size_t to int or unsigned int that may lead to a loss of data. In this specific situation, there is no loss of data due to the small file sizes that we will be working with. Moreover, some of the return types of the lab specify an unsigned int which is why the change to size_t has not been made. Lastly, there is an issue where some of the for loops will execute indefinately if the type change were to be made and thus the warning will continue to appear. These warnings have been noted and the changes were purposely not made in order to allow for the full functioning of the code.

Errors:
 1. Logical Error - Originally the ls command utilized the getFileNames() with an incorrect return type of string instead of set<string>. This was really not a major issue because the code simply had to be moved from one cpp file to another and there were no real changes to be made to obtain a string from a set of strings. Ultimately the correct return type (as specified in lab) was utilized. 
 2. Error - Often forgot to close files after opening them.
 3. Error? - Had a missing constructor - MacroCommand doesn't particularly need to take in an AFS, but the usage in the UnitTests require a constructor that takes in an AFS.
 4. Logical Error - Originally we had metadata displayed as "<Field name>: <value>\n", so "Name: <name>\nType: <type>\nSize: <size>", instead of just "<name> <type> <size>"(with appropriate spacing).
 5. Erro - Forgot to break in trailing whitespace removal code.